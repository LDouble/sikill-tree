# 存储器管理
## 程序的装入和链接
### 绝对装入方式
在编译的时候，就确定了程序在内存中的位置，那么此时就能够指定程序在内存中的实际地址。只适用于单道程序环境。
### 可重定位装入方式
在多道程序环境下，绝对编译程序无法得知编译的目标模块在内存的何处。在装入时，进行目标程序中指令和修改过程的重定向，由于是在转入手一次性完成，之后不会在调整，所以为静态重定位。（<span color="red">不适用于程序可移动的情况</span>）
### 动态运行时装入
在运行的过程中，程序可能在内存中会改变位置，因此动态运行时装入，在装入时不进行地址抓去哪换， 而是在运行的时候才会转换。借助于重定位寄存器。

## 程序的链接
### 静态链接
编译时一次性链接成一个程序。以后不再分开。
### 装入时动态链接
边装入边链接
> 优点:
1. 便于修改和更新
2. 便于实现对模板模块的共享
### 运行时动态链接
执行时候需要某个模板才进行链接。
> 优点: 加快了程序的装入过程，还能节约大量的内存。

## 内存的分配方式
### 连续分配
#### 单一连续
只适用于单用户、单任务的操作系统，把内存分为用户区和系统区。

#### 固定分区
> 将内存分割为n个分区，每个分区可载入一道作业，这几个分区，则允许几个作业并发作业。

> 缺点
1. 缺乏灵活性。
2. 造成空间的浪费。

#### 动态分区分配
> 根据进程的需要，动态的分配内存空间。分区分配算法如下
1. 首次适应算法: 缺点是留下很小的空闲分区，难以利用。增加了查找可用分区的时间大学。
2. 循环首次适应算法： 从上次适应的地方继续找，弥补了首次适应算法的缺陷，但是找不到大的空闲分区。
3. 最佳适应算法: 缺点是留下很多碎片不能被利用
4. 最坏适应算法:剩下的空闲去不会很小，产生碎片几率较小。
5. 快速适应算法: 对分区进行按大小分类。

#### 伙伴系统
> 伙伴系统规定，无论是已分配分区还是空闲分区，他的大小都必须是2的k次幂。 

### 分页管理
> 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。实现了非连续分配,以便解决内存碎片问题

### 分段管理
> 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。
段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间是二维的。

### 段页式管理
> 分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。
在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。

### 分段和分页的区别
1. 页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.
2. 页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.
3. 分页的作业地址空间是一维的.分段的地址空间是二维的.

### 置换算法
1. 先进先出法：（置换次数比较多）
2. 最佳置换法（OPT）：选择将来不再使用或在最远的将来才被访问的页调换出去（不便于实现）
3. 最近最少使用置换法（LRU）:当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以淘汰
4. 最近未使用置换法（NUR）：是LRU算法的近似方法，选择在最近一段时间里未被访问过的页面予以淘汰
